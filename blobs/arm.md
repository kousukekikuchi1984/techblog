# 普段のコーディング時に意識したい CPU の特性

## Introduction

社長 > おーい、お前、そろそろ技術ブログ書いておいて。書かないと減給な。

```
メロスは激怒した。必ず、かの邪智暴虐の社長を除かなければならぬと決意した。メロスには何を書けば良いのかがわからぬ。メロスは、村のエンジニアである。コードを書き、コンピュータと遊んで暮して来た。けれども減給に対しては、人一倍に敏感であった。
```

ということがあったかどうかは定かではありませんが、基本私はチキンです。どれだけチキンかというと "骨なしチキンのお客様"とコンビニで言われたら、"Nobody call me chicken!" と言うくらいのチキンです。せめてものの社長への抵抗として、実務的にはあまり役にたたない知識を techblog として記したいと思います。
私は正式にコンピューターサイエンスという学問を学んだことがありません。日頃から業務に当たる上で、コンピューターサイエンスを学んでおかないといけない適切な設計はできないな、と思うようになり、コンピューターサイエンスを学んでいる最中です。

中でも CPUの構造がアプリケーションレイヤーに出てくる点が今まで経験したことがないが、物理レベルのアーキテクチャの設計思想がアプリケーションレイヤーに及ぶことがありうると聞いて衝撃を受けたことがあります。これがありうる例となぜそうなるのかを話したいと思います。


## 同じように見えて挙動が異なるコード

### 問題 1.

突然ですが、この二つのコード配列のアクセスが違いますが、どちらも同じ速度で動くと思いますか？

```rust
fn main() {
    let mut array1 = vec![vec![1; 10000]; 10000];
    let array2 = vec![vec![2; 10000]; 10000];
    for j in 0..10000 {
        for i in 0..10000 {
            array1[j][i] = array2[j][i];
        }
    }
}
```

```rust
fn main() {
    let mut array1 = vec![vec![1; 10000]; 10000];
    let array2 = vec![vec![2; 10000]; 10000];
    for i in 0..10000 {
        for j in 0..10000 {
            array1[j][i] = array2[j][i];
        }
    }
}
```

これらのコードは for 内で配列を array2 から array1 に値を移行しています。
これらの違いは配列へのアクセスの違いです。具体的には、二重配列の外側から最初にアップデートするのか、それとも内側からアップデートするかの違いです。
検証のために実際に動かしてみましょう。
便宜上、上記のコードのうち、上のものを former, 下のものを latter とします。

``` sh
> time ./target/debug/former
./target/debug/fast  9.25s user 0.36s system 99% cpu 9.620 total

```


```sh
> time ./target/debug/slow
./target/debug/slow  32.37s user 0.49s system 99% cpu 32.865 total
```

と、結果をみると3倍以上差が出ていることに驚くと思います。これはなぜ発生するのでしょうか？ これは実は CPU のキャッシュに由来しています。

注. 今回用いる CPU は Apple Silicon の M2 Pro ですが、別の CPU でも発生しえます。

## CPU についてかるく説明

### CPU の構造のおさらい

- CPU が具体的な計算処理をするためには、レジスタにデータがある必要がある
- 計算処理の時には、あるレジスタに対する操作をする仕組みになっています。
- 例えば、アドレス A と アドレス B にある値を加算する場合は

```

```

### CPU のキャッシュ

- 上記の例だと定数を定義しそれを計算しています。しかしながら、普段僕らが用いている場合は動的に値を用いたいため常に値がレジスタに存在するわけではありません。
- そのためにCPU はデータをメモリからデータを取得しに行きます。
- もちろん、CPU とメモリは動作速度が異なり、またメモリが離れているため、相当遅いです。CPU の処理のうちメモリの待ち時間がかなりを占めます。
- そこで CPU 内キャッシュを作り、メモリからデータを fetch した際に、キャッシュにその関連するデータを格納する仕組みがあります。
- キャッシュのメカニズムとしては、キャッシュラインと呼ばれる固定サイズのブロックでデータを格納します。
- CPU がキャッシュにデータを取得する時に、キャッシュにデータがある時には CPU は高速にデータを取得できます。
- 対して キャッシュにデータがない場合は、メモリからデータを取得します。
  - その際に、それと関連があるデータを取得してきます。


## 配列のアクセスの仕方の違いによる速度変化

- CPU はキャッシュを格納する時に、必要としているデータとその周辺にあるデータを格納します。
- 配列であれば配列が周辺にあるデータとして選ばれることとなります。
- 今回の話に戻り、二重配列の内部配列のみを先に更新する方法だと、すでにキャッシュに存在するデータを用いることになる。
- 対して、二重配列の内部のポインタを固定し、参照する配列を変化させるると、キャッシュに存在しないデータを用いることになるので、遅くなります。



