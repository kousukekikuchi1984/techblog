# CPU の cache の特性に関して

## ネタ箇所

- 走れメロス
  - 暴虐な社長
  - しかし減給には敏感であった
- はい、チキン野郎です。
  - どれだけチキンかというと "骨なしチキンのお客様" とコンビニで言われたら、"Nobody call me chicken!" と言うくらいのチキンやろうです。
- せめてものの抵抗として、あまり役にたたない知識を techblog として記したいと思います。
- 今回は CPU の特性に関してです。

## CPU

### 問題

突然ですが、この二つのコード配列のアクセスが違いますが、どちらも同じ速度で動くと思いますか？

```rust
fn main() {
    let mut array1 = vec![vec![1; 10000]; 10000];
    let mut array2 = vec![vec![2; 10000]; 10000];
    for i in 0..10000 {
        for j in 0..10000 {
            array1[j][i] = array2[j][i];
        }
    }
}
```

```rust
fn main() {
    let mut array1 = vec![vec![1; 10000]; 10000];
    let mut array2 = vec![vec![2; 10000]; 10000];
    for j in 0..10000 {
        for i in 0..10000 {
            array1[j][i] = array2[j][i];
        }
    }
}
```

これらのコードは for 内で配列を array2 から array1 に値を移行しています。
これらの違いは配列へのアクセスの違いです。具体的には、二重配列の外側から最初にアップデートするのか、それとも内側からアップデートするかの違いです。
検証のために実際に動かしてみましょう。

```

```


```

```

実際には2倍あまり時間がかかっています。そして、比較的低レベルなC言語のみならず、Python でも同じ事象は発生します。
この違いはなぜ発生しているのでしょうか？ これを紐解くのは CPU の内部構造です。
注. 今回用いるのは ARM コアですが、基本的には x86 系統の CPU でも変わらないです。

